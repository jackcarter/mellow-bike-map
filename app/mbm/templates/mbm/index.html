{% extends "mbm/base.html" %}
{% load compress %}
{% load leaflet_tags %}
{% load static %}

{% block title %}{{ view.title }}{% endblock %}

{% block extra_css %}{% leaflet_css %}{% endblock %}

{% block body %}
  <div class="container-fluid my-2">
    <input id="source_text" name="source_text" placeholder="Start address" style="width:300px"></input>
    <input id="source" name="source_text" hidden="true"></input>
    <input id="target_text" name="target_text" placeholder="End address" style="width:300px"></input>
    <input id="target" name="target" hidden="true"></input>
    <button id="submit" class="btn btn-primary">Search</input>
  </div>
  <div id="map"></div>
{% endblock %}

{% block extra_js %}
  {% leaflet_js %}
  <script
    type="text/javascript"
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBvdUtVFRDt4QG1AcU7Vt3N1SULbxri44M&libraries=places"
  >
  </script>
  <script type="text/javascript">
    const routeListUrl = "{% url 'route-list' %}"
    const routeUrl = "{% url 'route' %}"

    const getLineColor = (type) => {
      switch (type) {
        case 'street': return 'green'
        case 'route': return 'orange'
        case 'path': return 'pink'
        default: return 'blue'
      }
    }

    document.addEventListener('DOMContentLoaded', (event) => {
      const map = L.map('map').setView([41.87, -87.62], 11);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: 'Map data &copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors',
      }).addTo(map)
      let routeLayer, allRoutesLayer;  // Init empty layers

      $.getJSON(routeListUrl).done(function(data) {
        allRoutesLayer = L.geoJSON(data, {
          style: function(feature) {
            return {color: getLineColor(feature.properties.type), opacity: 0.8}
          }
        }).addTo(map)
      }).fail(function(jqxhr, textStatus, error) {
        console.log(textStatus + ': ' + error)
      })

      $('#submit').click(function(e) {
        const source = $('#source').val()
        const target = $('#target').val()
        if (source === '') {
          alert('Source is required for search')
        } else if (target == '') {
          alert('Target is required for search')
        } else {
          $.getJSON(routeUrl + '?' + $.param({source, target})).done(function(data) {
            if (routeLayer) {
              map.removeLayer(routeLayer)
            }
            routeLayer = L.geoJSON(data.route, {
              style: function(feature) {
                return {weight: 5, color: getLineColor(feature.properties.type)}
              },
              onEachFeature: function(feature, layer) {
                layer.bindPopup(
                  '<strong>Name:</strong> ' + feature.properties.name + '<br>' +
                  '<strong>Type:</strong> ' + feature.properties.type
                )
              }
            }).addTo(map)
            map.fitBounds(routeLayer.getBounds())
          }).fail(function(jqxhr, textStatus, error) {
            const err = textStatus + ': ' + error
            alert('Request failed: ' + err)
          })
        }
      })

      // Address components for autocomplete
      const canonicalComponents = [
        ['street_number', 'short_name', ' '],
        ['route', 'long_name', ', '],
        ['locality', 'long_name', ', '],
        ['administrative_area_level_1', 'short_name', ' '],
        ['postal_code', 'short_name', '']
      ]

      const initAutocomplete = (textElementId, coordElementId, marker) => {
        // Create the autocomplete object, restricting the search predictions to
        // geographical location types.
        let autocomplete = new google.maps.places.Autocomplete(
          document.getElementById(textElementId),
          {types: ['geocode']}
        )
        // Avoid paying for data that you don't need by restricting the set of
        // place fields that are returned to just the address components.
        autocomplete.setFields(['address_component', 'geometry'])
        // When the user selects an address from the drop-down, populate the
        // address fields in the form.
        autocomplete.addListener('place_changed', () => {
          // Get the place details from the autocomplete object.
          const place = autocomplete.getPlace()

          const lat = place.geometry.location.lat()
          const lng = place.geometry.location.lng()
          document.getElementById(coordElementId).value = `${lat},${lng}`

          // Get each component of the address from the place details,
          // and then fill-in the corresponding field on the form.
          let addressString = ''
          for (const canonicalComponent of canonicalComponents) {
            const componentId = canonicalComponent[0]
            const componentType = canonicalComponent[1]
            const componentSuffix = canonicalComponent[2]
            for (const addressComponent of place['address_components']) {
              if (addressComponent.types.includes(componentId)) {
                addressString += addressComponent[componentType] + componentSuffix
                break
              }
            }
          }
          document.getElementById(textElementId).value = addressString

          if (marker) {map.removeLayer(marker)}
          marker = L.marker([lat, lng]).bindPopup(addressString).addTo(map)
          map.setView([lat, lng])
        });

        // Bias the autocomplete object to the user's geographical location,
        // as supplied by the browser's 'navigator.geolocation' object.
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(position => {
            geolocation = {
              lat: position.coords.latitude,
              lng: position.coords.longitude
            }
            if (!hasZoomedToUser) {
              map.setView([geolocation.lat, geolocation.lng], 14)
            }
            const circle = new google.maps.Circle({
              center: geolocation,
              radius: position.coords.accuracy
            })
            autocomplete.setBounds(circle.getBounds())
          })
        }
      }

      let hasZoomedToUser = false
      let sourceMarker, targetMarker
      initAutocomplete('source_text', 'source', sourceMarker)
      initAutocomplete('target_text', 'target', targetMarker)
    })
  </script>
{% endblock %}
